import asyncio
import argparse
import aiofiles
import ipaddress
from alive_progress import alive_bar
from colorama import Fore, Style
import random
import os
import socket

green = Fore.GREEN
magenta = Fore.MAGENTA
cyan = Fore.CYAN
mixed = Fore.RED + Fore.BLUE
red = Fore.RED
blue = Fore.BLUE
yellow = Fore.YELLOW
white = Fore.WHITE
reset = Style.RESET_ALL
bold = Style.BRIGHT
colors = [ green, cyan, blue]
random_color = random.choice(colors)

def banner():
    banner=f"""{bold}{random_color}
  ____ __     __ _____  _   _                _               
 / ___|\ \   / /| ____|| | | | _   _  _ __  | |_   ___  _ __ 
| |     \ \ / / |  _|  | |_| || | | || '_ \ | __| / _ \| '__|
| |___   \ V /  | |___ |  _  || |_| || | | || |_ |  __/| |   
 \____|   \_/   |_____||_| |_| \__,_||_| |_| \__| \___||_| 
     CVE-2024-6387                      {bold}{white}@th3gokul{reset}\n"""
    return banner


print (banner())

parser = argparse.ArgumentParser(description=f"[{bold}{blue}Description{reset}]: {bold}{white}Vulnerability Detection and Exploitation  tool for CVE-2024-6387" , usage=argparse.SUPPRESS)
parser.add_argument("-ip", "--ipaddress", type=str, help=f"[{bold}{blue}INF{reset}]: {bold}{white}Specify a ip or domain for vulnerability detection")
parser.add_argument("-l", "--list", type=str, help=f"[{bold}{blue}INF{reset}]: {bold}{white}Specify a list of ips for vulnerability detection")
parser.add_argument("-t", "--threads", type=int, default=1, help=f"[{bold}{blue}INF{reset}]: {bold}{white}Number of threads for list of ips")
parser.add_argument("-p","--port", type=int, default=22, help="Port number to check (default: 22).")
parser.add_argument("-b","--banner",action="store_true",help=f"[{bold}{blue}INF{reset}]: {bold}{white}Print the banner of vulnerable targets")
parser.add_argument("-v", "--verbose", action="store_true", help=f"[{bold}{blue}INF{reset}]: {bold}{white}Increases verbosity of output in console")
parser.add_argument("-to","--timeout", type=int,default=5,help=f"[{bold}{blue}INF{reset}]: {bold}{white}Timeout value for socket connection (Default=5)")
parser.add_argument("-o", "--output", type=str, help=f"[{bold}{blue}INF{reset}]: {bold}{white}Filename to save output of vulnerable target{reset}]")
args=parser.parse_args()

async def save(result):
    try:
            if args.output:
                if os.path.isfile(args.output):
                    filename = args.output
                elif os.path.isdir(args.output):
                    filename = os.path.join(args.output, f"results.txt")
                else:
                    filename = args.output
            else:
                    filename = "results.txt"
            async with aiofiles.open(filename, "a") as w:
                    await w.write(result + '\n')
    except KeyboardInterrupt as e:        
        quit()
    except asyncio.CancelledError as e:
        SystemExit
    except Exception as e:
        pass
  

    
async def get_ssh_banner(ip):
    try:
        reader , writer = await asyncio.wait_for(asyncio.open_connection(ip,args.port),args.timeout)
        banner = await asyncio.wait_for(reader.read(1024),args.timeout)
        writer.close()
        await writer.wait_closed()
        return banner.decode().strip()
    except (asyncio.TimeoutError,socket.gaierror,ConnectionRefusedError,TimeoutError,OSError):
        pass
    except Exception as e:
        print(f"Exception in banner: {e} , {type(e)}")
async def exploit(ip,sem,bar):

    try:
        banner = await get_ssh_banner(ip)    
        vulnerable_versions = [
        'SSH-2.0-OpenSSH_8.5p1', 'SSH-2.0-OpenSSH_8.6p1', 'SSH-2.0-OpenSSH_8.7p1', 
        'SSH-2.0-OpenSSH_8.8p1', 'SSH-2.0-OpenSSH_8.9p1', 'SSH-2.0-OpenSSH_9.0p1', 
        'SSH-2.0-OpenSSH_9.1p1', 'SSH-2.0-OpenSSH_9.2p1', 'SSH-2.0-OpenSSH_9.3p1', 
        'SSH-2.0-OpenSSH_9.4p1', 'SSH-2.0-OpenSSH_9.5p1', 'SSH-2.0-OpenSSH_9.6p1', 
        'SSH-2.0-OpenSSH_9.7p1'
            ]
        if banner is None:
            return
        banners=f"{banner}" if args.banner else ""
        for version in vulnerable_versions:
            if version in banner:
                print(f"[{bold}{green}VULN{reset}]: {bold}{white}{ip}:{args.port} {bold}{green}{banners} {reset}")
                await save(f"{ip}:{args.port} {banners}")
    except Exception as e:
        print(f"Exception at exploit: {e},{type(e)}")
    finally:
        bar()
        sem.release()


async def loader(ips, sem, bar):
    try:
        tasks = []
        for ip in ips:
            await sem.acquire() 
            task = asyncio.ensure_future(exploit( ip, sem, bar))
            tasks.append(task)
        await asyncio.gather(*tasks, return_exceptions=False)
    except KeyboardInterrupt as e:
        SystemExit
    except asyncio.CancelledError as e:
        SystemExit
    except Exception as e:
        if args.verbose:
            print(f"Exception in loader: {e}, {type(e)}")

async def threads(ips):
    try:
        sem = asyncio.BoundedSemaphore(args.threads)
        with alive_bar(title=f"CVEHunter", total=len(ips), enrich_print=False) as bar:
            await loader(ips, sem, bar)
    except RuntimeError as e:
        pass
    except KeyboardInterrupt as e:
        SystemExit
    except Exception as e:
        if args.verbose:
            print(f"Exception in threads: {e}, {type(e)}")


async def cidrs(cidr):
    try:
        ips=[]
        network = ipaddress.ip_network(cidr, strict=False)
        for ip in network:
            ips.append(str(ip))
        return ips
    except KeyboardInterrupt as e:
        exit()
    except ValueError as e:
        print(f"[{bold}{red}WRN{reset}]: {bold}{white}Invaild CIDR Detected{reset}")
        exit()
    except Exception as e:
        pass

async def main():
    try:
        ips=[]
        if args.ipaddress:
           
            if "/" in args.ipaddress:
                ips=await cidrs(args.ipaddress)
                await threads(ips)
        
            else:
                ips=[args.ipaddress]
                await threads(ips)
        if args.list:
            async with aiofiles.open(args.list, "r") as streamr:
                async for ip in streamr:
                    ip = ip.strip()
                    if "/" in ip:
                        cidr=await cidrs(ip)
                        for value in cidr:
                            ips.append(value)
                    else:
                        ips.append(ip)
            await threads(ips)       

    except Exception as e:
        print(f"exception in main: {e} , {type(e)}")

if __name__ == "__main__":
    asyncio.run(main())
